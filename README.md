# CS255 - Systems Analysis and Design

#Briefly summarize the DriverPass project. Who was the client? What type of system did they want you to design?
The project involved designing a web application for DriverPass, a company centered around training drivers in the rules of the road so they can more easily pass their DMV exams. The client wanted a web interface where users could select a package deal, view their progress through the course, and schedule driving sessions.

#What did you do particularly well?
I think I did a fairly good job of presenting a simplified and easy-to-understand representation of the various systems that make up the DriverPass web application. My goal was to create diagrams and design documents that were uncluttered and easy for even the layperson to understand.

#If you could choose one part of your work on these documents to revise, what would you pick? How would you improve it?
If I could revise one part of this project, it would probably be the use case diagram. I feel a bit like, in my quest to simplify things, I may have oversimplified the use case diagram a bit. Certain use cases depicted on the diagram might need more explanation.

#How did you interpret the user’s needs and implement them into your system design? Why is it so important to consider the user’s needs when designing?
I interpreted the users needs by considering what they had communicated in the intial interview transcript and then applying standard industry practices to achieve the desired results. I also considered how each different type of user of this system would presumably use the system on a day-to-day basis and tried to consider all perspectives.

#How do you approach designing software? What techniques or strategies would you use in the future to analyze and design a system?
When designing software, my first step is to create a sort of mental map of the software being designed. After I have mentally discerned the broad strokes of the software, I then create diagrams and pseudocode to more procedurally think through the actual tasks that the software will perform. From there, I generally try to consider which parts of the software can be combined or simplified to keep things clean and streamlined.
